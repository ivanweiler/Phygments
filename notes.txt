Goals
- highlight html+js+php mixed code with Pygments php port
- make full Pygmants php port with community help

Roadmap
- define structure similar to Pygments - DONE
- implement lexer abstract, regex lexer and basic html lexer - DONE
- html formatter and html lexer without any guess or file load functionality - DONE
- other web-relevant lexers - php, js, sass .. - WIP
- consider non-generator version? (php<5.5) - NO, too much work
- other Pygments functionalities (Filters, main Formaters, language detection, etc.)
- implement and test all languages - community help needed
- unicode support?


Current
- solve STANDARD_TYPES to Token map problem, finish Styles logic - DONE
- finalize bygroups, calls, includes, etc. - DONE
- I'm not too happy how Token aliases are implemented - DONE (it's ok)
- fix Php lexer - DONE
- check and fix all regex definitions (\ and #) - DONE
- finalize HtmlPhp lexer + Delegating
- implement guess lexer functionality
- initial beta release


Lexer convert
# => \#  no?
r'\\' => \\\\ yes

Every r'\' needs to be written as '\\' in PHP.
I converted few r'\#XYZ' to '#XYZ'; is # special preg char in python?? 

RegexLexer match logic notes
Pythons re.match() is matching start of the string, Phps preg_match() is matching whole string. 
We can always catch PREG_OFFSET_CAPTURE and compare it to zero, but engine is going through whole
string all the time, can we optimize that?

#\GPATTERN_HERE#m should be ok?



OLD:
If we add ^ to the begining of pattern, it will still go through whole string and match something 
in MULTILINE mode;
If we add \A to the begining of pattern, we are unable to match ^pattern tokens which exist in 
some languages. For example, with offset, in MULTILINE mode to match only when we're after \n.
Same thing when we use substr() to cut text, we're losing ^pattern tokens, since we can't know 
if they come after \n or not.

I'll most likely implement PREG_OFFSET_CAPTURE=0 logic for start, but it could maybe work 
to use \A+pattern while remembering last [-1] char from previous match, to know if it's new line or not.

#\A(?:.|\n)PATTERN_HERE#m  =>  prev_char+CURRENT_TEXT_TO_MATCH

It seems \A in front speeds up preg_match(), it makes sense. I did few simple tests, but further testing 
is needed.

